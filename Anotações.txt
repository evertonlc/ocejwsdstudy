1. Create an SOAP web service in a servlet container
    1.1. Create a web service starting from a WSDL file using JAX-WS
    1.2. Create a web service using JAX-WS annotations

2. Create a RESTful web service in a servlet container
    2.1. Create a web service using JAX-RS, refer to Jersey implementation for examples

3. Create a SOAP based web service implemented by an EJB component
    3.1. Create an EJB web service implementations using annotations (@Stateless or @Singleton)
    3.2. Create a web service starting from a Java source using JAX-WS

4. Create a RESTful web service implemented by an EJB component
    4.1. Create a web service using JAX-RS from EJB classes.

5. Configure Java EE security for a SOAP web service
    5.1. Configure security requirements of service using Java EE-container based security (overlaps with steps in other tasks - repeated here for convenience)

6. Create a web service client for a SOAP based web service
    6.1. Create a standalone client.
    6.2. Create a client in a managed component in a EE container.
        * Criar um cliente para um webservice baseado em SOAP.
            - Standalone
            - Em um managed server
                + Pode ser feito usando @WebServiceRef

            - Dymanic proxy client: Classes compiladas a partir da SEI fornecida.
                + Geradas a partir do wsimport:
                    + SEI Service class;
                    + Exceptions da wsdl:fault;
                    + JAXB generated classes;
                + Os proxys dinâmicos extendem a classe javax.lang.reflect.Proxy e são invocados de forma síncrona, assíncrona ou one-way

            - Dispatch client: Para ser usando quando se quer trabalhar as mensagens a nivel de XML, ou quando não quer usar artefatos gerados
                + O cliente é javax.xml.ws.Dispatch e é de forma síncrona, assíncrona ou one-way
                + Quando usa o modo MESSAGE, o cliente é responsável por fornecer toda a mensagem SOAP (Envelope, Header e Body);
                + Quando usa o modo PAYLOAD, o cliente é responsável somente por fornecer o <soap:Body>, o JAX-WS inclui ele num <soap:Envelope>;


7. Create a web service client for a RESTful web service
    REST Client
        * Jersey Client API
            Client client = Client.create();
            WebResource webResource = client.resource(url);
                webResource.get/post/put...
                webResource.accept(mimetype)
                webResource.entity(value, mimetype)

        * Java SE Client

8. Create a SOAP based web service using Java SE platform.
    8.1. Create a web service starting from a WSDL file using JAX-WS.
    8.2. Create a web service starting from a Java source using JAX-WS.

9. Create handlers for SOAP web services.
    9.1. Configure SOAP and logical handlers on the server side.
    9.2. Configure SOAP and logical handlers on the client side.

10. Create low-level SOAP web services.
    10.1. Java API for XML Processing (JAXP)
        Simple API for XML Parsing (SAX) - Fazer parse de dados como uma stream de eventos - Rápido e eficiênte, ideal para
            processamento sem estado. Menos memória que do DOM, pois não constrói uma representação interna.
        Streaming API for XML (StAX) standard - Se existe um estado a ser mantido
            Cursor API - XMLStreamReader, XMLStreamWriter (Eficiência)
            Iterator API - XMLEventReader, XMLEventWriter (Flexibilidade, extensibilidade, facilidade de desenvolvimento). Permite leitura e escrita, diferente do SAX que só permite leitura
        Document Object Model (DOM) - Fazer o parse de dados montando uma representação num objeto - Mais lento que o SAX,
            pois constrói representação interna num objeto. Bastante útil quando precisa modificar a estrutura do XML;
        Extensible Stylesheet Language Transformations (XSLT) - Para transformação de dados;
        APIs definidas no pacote 'javax.xml.parsers'. Contém as classes de factory SAXParserFactory, DocumentBuilderFactory, and TransformerFactory que dão as classes SAXParser, a DocumentBuilder, e um XSLT transformer

    10.2. Java Architecture for XML Binding (JAXB)
        Fornece uma forma de fazer o bind entre XML schemas e a representação Java.
        Fornece mecanismos para fazer o unmarshalling de documentos XML em árvores java e o prcesso reverso.
        Fornece uma forma de gerar documentos XML de objetos java.

        Bind process
        1. Gera classes baseadas em um esquema XML;
        2. Compila as classes
        3. Unmarshal: Converte o XML em uma árvore
        4. Generate content tree
        5. Validate (opcional)
        6. Process content (Modificar os dados XML representados pela árvore por interfaces geradas pelo compilador)
        7. Marshal: Converte os dados na árvore e gera um ou mais documentos XML)

        javax.xml.bind.JAXBContext
            - interface para geranciar XML/Java binding para unmarshal, marshal e validation
            - Criado através do newInstance(contextPath), onde o contextPath é uma lista de pacotes que contém classes derivadas
                de algum esquema
        javax.xml.bind.Unmarshaller
            - interface usada para fazer a deserialização de XML em árvores de objetos java, podendo fazer validação dos dados enquanto desempacota.
        javax.xml.bind.Marshaller
            - interface usada para fazer a serialização de árvores de objetos java em XML.

        Validation
            - Fail-fast: Runtime check
            - On-demand: Aplicação pode chamar Validator.validade na java content tree;
    10.3. Use Provider API to create a web service.
        SAAJ (SOAP with Attachments API for Java) - API do java para enviar e receber mensagens SOAP. Classes dentro do javax.xml.soap
            SOAPMessage, SOAPPart, SOAPEnvelope, SOAPHeader, SOAPBody, SOAPBodyElement
            SOAPFault <faultstring, faultcode>

        10.3.2.  Process only the SOAP body, using JAXB.

    10.4.  Use Dispatch API to create a dynamic web service client.
        A interface javax.xml.ws.Dispatch permite trabalhar com JAX-WS no nível do XML.
        Suporta dois modos de uso:
            - javax.xml.ws.Service.Mode.MESSAGE = O cliente é responsável por criar as estruturas específicas do protocolo.
            - javax.xml.ws.Service.Mode.PAYLOAD = O cliente se preocupa somente com o conteúdo interno da mensagem.
        Para se usar a Dispatch é necessário que a implementação suporte um dos seguintes tipos:
            - javax.xml.transform.Source
            - JAXB Objects
            - javax.xml.soap.SOAPMessage
            - javax.activation.DataSource (usadas somente quando usar o Dispatch que use o modo de binding HTTP)
        Suporta 3 modos de invocação:
            - Síncrono (invoke methods);
            - Assíncrono (invokeAsync) - Pode receber o resultado via:
                - Polling: invokeAsync(T msg) - Response é uma implementação de 'java.util.concurrent.Future<T>'
                    while(objectResponse.isDone()) {}
                - Callback: invokeAsync(T msg, javax.xml.ws.AsyncHandler<T> handler) - implementa a interface e trata no handler;
            - OneWay (invokeOneWay - fire-and-forget)

        BindingProviders - javax.xml.ws.BindingProvider

11. Use MTOM (Message Transmission Optimized Mechanism) and MIME in a SOAP web service.
    Enviar dados binários em requisições SOAP.
    11.1. Use MTOM on the service.
    11.2. Use MTOM on the client.

12. Use WS-Addressing with a SOAP web service
    WS-Addressing is a World Wide Web Consortium (W3C) specification that aid interoperability between web services
        by defining a standard way to address web services and to provide addressing information in messages.
    - Endpoint references
    - Message addressing properties
    12.1. Use Addressing on the service.
    12.2. Use Addressing on the client.

13. Configure Message Level security for a SOAP web service

14. Apply best practices to design and implement web services.